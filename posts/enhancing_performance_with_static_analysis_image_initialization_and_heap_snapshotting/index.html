<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Liste - https://iqnev.github.io/">
    <title>Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting | Codes are a puzzle</title>
    <meta name="description" content="A minimal hugo theme focus on content">
    <meta property="og:url" content="https://iqnev.github.io/posts/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting/">
  <meta property="og:site_name" content="Codes are a puzzle">
  <meta property="og:title" content="Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting">
  <meta property="og:description" content="From monolithic structures to the world of distributed systems, application development has come a long way. The massive adoption of cloud computing and microservice architecture has significantly altered the approach to how server applications are created and deployed. Instead of giant application servers, we now have independent, individually deployed services that spring into action as and when needed.
However, a new player on the block that can impact this smooth functioning might be ‘cold starts.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T11:04:18+03:00">
    <meta property="article:modified_time" content="2024-05-15T11:04:18+03:00">
    <meta property="article:tag" content="Native">
    <meta property="article:tag" content="GraalVM">
    <meta property="article:tag" content="Compiler">
    <meta property="og:image" content="https://iqnev.github.io/images/graalvm-logo.png">

    
  <meta itemprop="name" content="Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting">
  <meta itemprop="description" content="From monolithic structures to the world of distributed systems, application development has come a long way. The massive adoption of cloud computing and microservice architecture has significantly altered the approach to how server applications are created and deployed. Instead of giant application servers, we now have independent, individually deployed services that spring into action as and when needed.
However, a new player on the block that can impact this smooth functioning might be ‘cold starts.">
  <meta itemprop="datePublished" content="2024-05-15T11:04:18+03:00">
  <meta itemprop="dateModified" content="2024-05-15T11:04:18+03:00">
  <meta itemprop="wordCount" content="1282">
  <meta itemprop="image" content="https://iqnev.github.io/images/graalvm-logo.png">
  <meta itemprop="keywords" content="Native,GraalVM,Compiler">
    
  


    <link rel="canonical" href="https://iqnev.github.io/posts/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting/">
    <link rel="icon" href="https://iqnev.github.io//assets/favicon.ico">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link href="https://www.google-analytics.com" rel="preconnect" crossorigin>
    <link rel="alternate" type="application/atom+xml" title="Codes are a puzzle" href="https://iqnev.github.io//atom.xml" />
    <link rel="alternate" type="application/json" title="Codes are a puzzle" href="https://iqnev.github.io//feed.json" />
    <link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=">
    
    
    <style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;background:#f5f5f5;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{margin:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}.post-date{margin:5% 0}.index-date{color:#9a9a9a}.animate-blink{animation:opacity 1s infinite;opacity:1}@keyframes opacity{0%{opacity:1}50%{opacity:.5}100%{opacity:0}}.tags{display:flex;justify-content:space-between}.tags ul{padding:0;margin:0}.tags li{display:inline}.avatar{height:120px;width:120px;position:relative;margin:-10px 0 0 15px;float:right;border-radius:50%} </style>
  
    
  
  
  <script type="application/ld+json">
  {
      "@context": "http://schema.org",
      "@type": "BlogPosting",
      "articleSection": "posts",
      "name": "Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting",
      "headline": "Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting",
      "alternativeHeadline": "",
      "description": "From monolithic structures to the world of distributed systems, application development has come a long way. The massive adoption of cloud computing and microservice architecture has significantly altered the approach to how server applications are created and deployed. Instead of giant application servers, we now have independent, individually deployed services that spring into action as and when needed.\nHowever, a new player on the block that can impact this smooth functioning might be \u0026lsquo;cold starts.",
      "inLanguage": "en-us",
      "isFamilyFriendly": "true",
      "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https:\/\/iqnev.github.io\/posts\/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting\/"
      },
      "author" : {
          "@type": "Person",
          "name": ""
      },
      "creator" : {
          "@type": "Person",
          "name": ""
      },
      "accountablePerson" : {
          "@type": "Person",
          "name": ""
      },
      "copyrightHolder" : "Codes are a puzzle",
      "copyrightYear" : "2024",
      "dateCreated": "2024-05-15T11:04:18.00Z",
      "datePublished": "2024-05-15T11:04:18.00Z",
      "dateModified": "2024-05-15T11:04:18.00Z",
      "publisher":{
          "@type":"Organization",
          "name": "Codes are a puzzle",
          "url": "https://iqnev.github.io/",
          "logo": {
              "@type": "ImageObject",
              "url": "https:\/\/iqnev.github.io\/images\/favicon.ico",
              "width":"32",
              "height":"32"
          }
      },
      "image": ["https://iqnev.github.io/images/graalvm-logo.png"],
      "url" : "https:\/\/iqnev.github.io\/posts\/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting\/",
      "wordCount" : "1282",
      "genre" : [ "native" , "graalvm" , "compiler" ],
      "keywords" : [ "native" , "graalvm" , "compiler" ]
  }
  </script>
  
  
  </head>

<body>
  <a class="skip-link" href="#main">Skip to main</a>
  <main id="main">
  <div class="content">
    <header>
<p style="padding: 0;margin: 0;">
  <a href="/">
    <b>Codes are a puzzle</b>
    <span class="text-stone-500 animate-blink">▮</span>
  </a>
</p>
<ul style="padding: 0;margin: 0;">
  
  
  <li class="">
    <a href="/about/"><span>About</span></a>
    
  <li class="">
    <a href="/posts/"><span>Posts</span></a>
    
  <li class="">
    <a href="/categories/"><span>Categories</span></a>
    
  </li>
</ul>
</header>
<hr class="hr-list" style="padding: 0;margin: 0;">
    <section>
      <h2 class="post">Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting</h2>
      <p>From monolithic structures to the world of distributed systems, application development has come a
long way. The massive adoption of cloud computing and microservice architecture has significantly
altered the approach to how server applications are created and deployed. Instead of giant
application servers, we now have independent, individually deployed services that spring into action
as and when needed.</p>
<p>However, a new player on the block that can impact this smooth functioning might be &lsquo;cold starts.&rsquo;
Cold starts kick in when the first request processes on a freshly spawned worker. This situation
demands language runtime initialization and service configuration initialization before processing
the actual request. The unpredictability and slower execution associated with cold starts can breach
the service level agreements of a cloud service. So, how does one counter this growing concern?</p>
<style>
.zoom {
  transition: transform .2s; /* Animation */
  margin: 0 auto;
}

.zoom:hover {
  transform: scale(2.0); /* Zoom when hovered */
}
</style>
<h2 id="native-image-optimizing-startup-time-and-memory-footprint">Native Image: Optimizing Startup Time and Memory Footprint</h2>
<p>To combat the inefficiencies of cold starts, a novel approach has been developed involving points-to
analysis, application initialization at build time, heap snapshotting, and ahead-of-time  <strong>(AOT)</strong>
compilation. This method operates under a closed-world assumption, requiring all Java classes to be
predetermined and accessible at build time. During this phase, a comprehensive points-to analysis
determines all reachable program elements (classes, methods, fields) to ensure that only essential
Java methods are compiled.</p>
<p>The initialization code for the application can execute during the build process rather than at
runtime. This allows for the pre-allocation of Java objects and the construction of complex data
structures, which are then made available at runtime via an  &ldquo;image heap&rdquo;. This image heap is
integrated within the executable, providing immediate availability upon application start. The
iterative execution of points-to analysis and snapshotting continues until a stable state (fixed
point) is achieved, optimizing both startup time and resource consumption.</p>
<h2 id="detailed-workflow">Detailed Workflow</h2>
<p>The input for our system is Java bytecode, which could originate from languages like Java, Scala, or
Kotlin. The process treats the application, its libraries, the JDK, and VM components uniformly to
produce a native executable specific to an operating system and architecture—termed a &ldquo;native
image&rdquo;. The building process includes iterative points-to analysis and heap snapshotting until a
fixed point is reached, allowing the application to actively participate through registered
callbacks. These steps are collectively known as the native image build process (<strong>Figure 1</strong>)</p>
<img class="zoom" src="/images/native-image-build-process.jpg" alt="Native Image Build Process" title="Native Image Build Process">
<br>
<p><em>Figure 1 – Native Image Build Process(source: redhat.com)</em></p>
<h2 id="points-to-analysis">Points-to Analysis</h2>
<p>We employ a points-to analysis to ascertain the reachability of classes, methods, and fields during
runtime. The points-to analysis commences with all entry points, such as the main method of the
application, and iteratively traverses all transitively reachable methods until reaching a fixed
point(<strong>Figure 2</strong>).</p>
<img class="zoom" src="/images/points-to-analysis.jpg" alt="Points-to-analysis" title="Points-to-analysis">
<br>
<p><em>Figure 2 – Points-to-analysis</em></p>
<p>Our points-to analysis leverages the front end of our compiler to parse Java bytecode into the
compiler’s high-level intermediate representation <strong>(IR)</strong>. Subsequently, the IR is transformed into
a
type-flow graph. In this graph, nodes represent instructions operating on object types, while edges
denote directed use edges between nodes, pointing from the definition to the usage. Each node
maintains a type state, consisting of a list of types that can reach the node and nullness
information. Type states propagate through the use edges; if the type state of a node changes, this
change is disseminated to all usages. Importantly, type states can only expand; new types may be
added to a type state, but existing types are never removed. This mechanism ensures that the
analysis ultimately converges to a fixed point, leading to termination.</p>
<h2 id="run-initialization-code">Run Initialization Code</h2>
<p>The points-to analysis guides the execution of initialization code when it hits a local fixed point.
This code finds its origins in two separate sources: Class initializers and custom code batch
executed at build time through a feature interface:</p>
<ol>
<li>
<p><strong>Class Initializers:</strong> Every Java class can have a class initializer indicated by a <code>&lt;clinit&gt;</code>
method,
which initializes static fields. Developers can choose which classes to initialize at build-time
vs runtime.</p>
</li>
<li>
<p><strong>Explicit Callbacks:</strong> Developers can implement custom code through hooks provided by our
system,
executing before, during, or after the analysis stages.</p>
</li>
</ol>
<p>Here are the APIs provided for integrating with our system:</p>
<h3 id="passive-api-queries-the-current-analysis-status">Passive API (queries the current analysis status)</h3>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#fc5fa3">boolean</span> <span style="color:#41a1c0">isReachable</span>(Class&lt;?&gt; clazz);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#fc5fa3">boolean</span> <span style="color:#41a1c0">isReachable</span>(Field field);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#fc5fa3">boolean</span> <span style="color:#41a1c0">isReachable</span>(Executable method);
</span></span></code></pre></div><p>For more information, refer to
the <a href="https://github.com/graalvm/labs-openjdk/blob/378138863fe29bae72f34eb8e3af8ab7c457baa6/src/jdk.internal.vm.ci/share/classes/jdk/vm/ci/runtime/JVMCICompiler.java#L35">QueryReachabilityAccess</a></p>
<h3 id="active-api-registers-callbacks-for-analysis-status-changes">Active API (registers callbacks for analysis status changes):</h3>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#fc5fa3">void</span> <span style="color:#41a1c0">registerReachabilityHandler</span>(Consumer&lt;DuringAnalysisAccess&gt; callback, Object... elements);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#fc5fa3">void</span> <span style="color:#41a1c0">registerSubtypeReachabilityHandler</span>(BiConsumer&lt;DuringAnalysisAccess, Class&lt;?&gt;&gt; callback, Class&lt;?&gt; baseClass);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#fc5fa3">void</span> <span style="color:#41a1c0">registerMethodOverrideReachabilityHandler</span>(BiConsumer&lt;DuringAnalysisAccess, Executable&gt; callback, Executable baseMethod);
</span></span></code></pre></div><p>For more information, refer to
the <a href="https://github.com/oracle/graal/blob/979124badd31e91224996ddd08aaf2e10bfeb37d/sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/hosted/Feature.java#L202">BeforeAnalysisAccess</a></p>
<p>During this phase, the application can execute custom code such as object allocation and
initialization of larger data structures. Importantly, the initialization code can access the
current points-to analysis state, enabling queries regarding the reachability of types, methods, or
fields. This is accomplished using the various <code>isReachable()</code> methods provided by
DuringAnalysisAccess. Leveraging this information, the application can construct data structures
optimized for the reachable segments of the application.</p>
<h2 id="heap-snapshotting">Heap Snapshotting</h2>
<p>Finally, heap snapshotting constructs an object graph by following root pointers like static fields
to build a comprehensive view of all reachable objects. This graph then populates the native image&rsquo;s
image heap, ensuring that the application&rsquo;s initial state is efficiently loaded upon startup.</p>
<p>To generate the transitive closure of reachable objects, the algorithm traverses object fields,
reading their values using reflection. It&rsquo;s crucial to note that the image builder operates within
the Java environment. Only instance fields marked as &ldquo;read&rdquo; by the points-to analysis are considered
during this traversal. For instance, if a class has two instance fields but one isn&rsquo;t marked as
read, the object reachable through the unmarked field is excluded from the image heap.</p>
<p>When encountering a field value whose class hasn&rsquo;t been previously identified by the points-to
analysis, the class is registered as a field type. This registration ensures that in subsequent
iterations of the points-to analysis, the new type is propagated to all field reads and transitive
usages in the type-flow graph.</p>
<p>The code snippet below outlines the core algorithm for heap snapshotting:</p>
<div class="highlight"><pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Declare List worklist := []
</span></span><span style="display:flex;"><span>Declare Set reachableObjects := []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Function BuildHeapSnapshot(PointsToState pointsToState)
</span></span><span style="display:flex;"><span>For Each field in pointsToState.getReachableStaticObjectFields()
</span></span><span style="display:flex;"><span>Call AddObjectToWorkList(field.readValue())
</span></span><span style="display:flex;"><span>End For
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    For Each method in pointsToState.getReachableMethods()
</span></span><span style="display:flex;"><span>        For Each constant in method.embeddedConstants()
</span></span><span style="display:flex;"><span>            Call AddObjectToWorkList(constant)
</span></span><span style="display:flex;"><span>        End For
</span></span><span style="display:flex;"><span>    End For
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    While worklist.isNotEmpty
</span></span><span style="display:flex;"><span>        Object current := Pop from worklist
</span></span><span style="display:flex;"><span>        If current Object is an Array
</span></span><span style="display:flex;"><span>            For Each value in current
</span></span><span style="display:flex;"><span>                Call AddObjectToWorkList(value)
</span></span><span style="display:flex;"><span>                Add current.getClass() to pointsToState.getObjectArrayTypes()
</span></span><span style="display:flex;"><span>            End For
</span></span><span style="display:flex;"><span>        Else
</span></span><span style="display:flex;"><span>            For Each field in pointsToState.getReachableInstanceObjectFields(current.getClass())
</span></span><span style="display:flex;"><span>                Object value := field.read(current)
</span></span><span style="display:flex;"><span>                Call AddObjectToWorkList(value)
</span></span><span style="display:flex;"><span>                Add value.getClass() to pointsToState.getFieldValueTypes(field)
</span></span><span style="display:flex;"><span>            End For
</span></span><span style="display:flex;"><span>        End If
</span></span><span style="display:flex;"><span>    End While
</span></span><span style="display:flex;"><span>    Return reachableObjects
</span></span><span style="display:flex;"><span>End Function
</span></span></code></pre></div><p>In summary, the heap snapshotting algorithm efficiently constructs a snapshot of the heap by
systematically traversing reachable objects and their fields. This ensures that only relevant
objects are included in the image heap, optimizing the performance and memory footprint of the
native image.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion, the process of heap snapshotting plays a critical role in the creation of native
images. By systematically traversing reachable objects and their fields, the heap snapshotting
algorithm constructs an object graph that represents the transitive closure of reachable objects
from root pointers such as static fields. This object graph is then embedded into the native image
as the image heap, serving as the initial heap upon native image startup.</p>
<p>Throughout the process, the algorithm relies on the state of the points-to analysis to determine
which objects and fields are relevant for inclusion in the image heap. Objects and fields marked
as &ldquo;read&rdquo; by the points-to analysis are considered, while unmarked entities are excluded.
Additionally, when encountering previously unseen types, the algorithm registers them for
propagation in subsequent iterations of the points-to analysis.</p>
<p>Overall, heap snapshotting optimizes the performance and memory usage of native images by ensuring
that only necessary objects are included in the image heap. This systematic approach enhances the
efficiency and reliability of native image execution.</p>

      
      <div class="post-date">
        <span class="g time">May 15, 2024 </span> &#8729;
         
         <a href="https://iqnev.github.io/tags/native/">native</a> <a href="https://iqnev.github.io/tags/graalvm/">graalvm</a> <a href="https://iqnev.github.io/tags/compiler/">compiler</a>
      </div>
      
    </section>
    
    <div id="comments">
      <script src="https://utteranc.es/client.js"
    repo=ZgotmplZ
    issue-term="pathname"
    theme=github-light
    crossorigin="anonymous"
    async>
</script>

    </div>
    
  </div>
</main>
</body>
</html>
