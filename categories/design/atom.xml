<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>design on Codes are a puzzle</title>
    <link>https://iqnev.github.io/categories/design/</link>
    <description>Recent content in design on Codes are a puzzle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Feb 2024 11:04:18 +0300</lastBuildDate>
    <atom:link href="https://iqnev.github.io/categories/design/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Challenge of Evolving Schemas in Message Queues</title>
      <link>https://iqnev.github.io/posts/the-challenge-of-evolving-schemas-in-message-queues/</link>
      <pubDate>Sun, 18 Feb 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/the-challenge-of-evolving-schemas-in-message-queues/</guid>
      <description>In systems built on message queues like RabbitMQ or Pub/Sub, schema evolution is inevitable. It allows you to adapt to changing needs and add new features, but it can also introduce challenges. When updating schemas, ensuring a smooth transition is crucial to avoid disrupting existing processes and consumers. Let&amp;rsquo;s explore a scenario where your schema undergoes significant changes:&#xA;Initial Payload (Version 1.0):&#xA;1{ 2 &amp;#34;eventType&amp;#34;: &amp;#34;user_created&amp;#34;, 3 &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, 4 &amp;#34;timestamp&amp;#34;: &amp;#34;2024-01-15T08:00:00Z&amp;#34;, 5 &amp;#34;data&amp;#34;: { 6 &amp;#34;id&amp;#34;: &amp;#34;123456789&amp;#34;, 7 &amp;#34;username&amp;#34;: &amp;#34;john_doe&amp;#34;, 8 &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, 9 &amp;#34;email&amp;#34;: &amp;#34;john.</description>
    </item>
  </channel>
</rss>
