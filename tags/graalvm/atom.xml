<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GraalVM on Codes are a puzzle</title>
    <link>https://iqnev.github.io/tags/graalvm/</link>
    <description>Recent content in GraalVM on Codes are a puzzle</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 May 2024 11:04:18 +0300</lastBuildDate>
    <atom:link href="https://iqnev.github.io/tags/graalvm/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Memory Management in GraalVM Native Image</title>
      <link>https://iqnev.github.io/posts/memory_management_in_graalvm_native_image/</link>
      <pubDate>Sun, 26 May 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/memory_management_in_graalvm_native_image/</guid>
      <description>Memory management is a crucial component of computer software development, tasked with the effective allocation, utilization, and release of memory in applications. Its importance lies in enhancing software performance and ensuring system stability.&#xA;Garbage Collection Garbage collection (GC) is pivotal in contemporary programming languages such as Java and Go. It autonomously detects and recycles unused memory, thereby alleviating the need for developers to manually manage memory. The concept of GC originally emerged in the LISP programming language in the late 1950s, marking the introduction of automated memory management.</description>
    </item>
    <item>
      <title>Enhancing Performance with Static Analysis, Image Initialization and Heap Snapshotting</title>
      <link>https://iqnev.github.io/posts/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting/</link>
      <pubDate>Wed, 15 May 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/enhancing_performance_with_static_analysis_image_initialization_and_heap_snapshotting/</guid>
      <description>From monolithic structures to the world of distributed systems, application development has come a long way. The massive adoption of cloud computing and microservice architecture has significantly altered the approach to how server applications are created and deployed. Instead of giant application servers, we now have independent, individually deployed services that spring into action as and when needed.&#xA;However, a new player on the block that can impact this smooth functioning might be &amp;lsquo;cold starts.</description>
    </item>
    <item>
      <title>Exploring Graal: Next-Generation JIT Compilation for Java</title>
      <link>https://iqnev.github.io/posts/exploring_graal_next_generation_jit_compilation_for_java/</link>
      <pubDate>Mon, 06 May 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/exploring_graal_next_generation_jit_compilation_for_java/</guid>
      <description>The Graal compiler is a radical leap forward in dynamic, Just-In-Time (JIT) compilation technology. Heralded as a significant factor behind Java&amp;rsquo;s impressive performance, the role and function of JIT compilation within the Java Virtual Machine (JVM) architecture often perplexes many practitioners due to its complex and rather opaque nature.&#xA;What is a JIT compiler? When you execute the javac command or use the IDE, your Java program is converted from Java source code into JVM bytecode.</description>
    </item>
    <item>
      <title>Turbocharge Java Microservices with Quarkus and GraalVM Native Image</title>
      <link>https://iqnev.github.io/posts/graalvm-native-image/</link>
      <pubDate>Sun, 07 Jan 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/graalvm-native-image/</guid>
      <description>In the dynamic landscape of modern software development, microservices have become the favored architectural approach. While this methodology offers numerous advantages, it is not without its challenges. Issues such as large memory footprints, extended start times, and high CPU usage often accompany traditional JVM-based services. These challenges not only impact the technical aspects but also have financial implications that can significantly affect the overall cost of running and maintaining software solutions.</description>
    </item>
    <item>
      <title>Registering Reflection in Quarkus Extensions</title>
      <link>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</link>
      <pubDate>Sun, 26 Nov 2023 14:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</guid>
      <description>Quarkus utilizes ahead-of-time (AOT) compilation to build blazing fast native executables. However, AOT works through closed-world analysis which eliminates unused code paths. This can break functionality relying on runtime reflection like dependency injection, bytecode manipulation, and integration with certain libraries.&#xA;Registering for Reflection When building a native executable, GraalVM operates under a closed-world assumption, analyzing the call tree and eliminating unused classes, methods, and fields. To include elements requiring reflective access, explicit registration becomes crucial.</description>
    </item>
  </channel>
</rss>
