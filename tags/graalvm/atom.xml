<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GraalVM on Codes are a puzzle</title>
    <link>https://iqnev.github.io/tags/graalvm/</link>
    <description>Recent content in GraalVM on Codes are a puzzle</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 May 2024 11:04:18 +0300</lastBuildDate>
    <atom:link href="https://iqnev.github.io/tags/graalvm/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exploring Graal: Next-Generation JIT Compilation for Java</title>
      <link>https://iqnev.github.io/posts/exploring_graal_next_generation_jit_compilation_for_java/</link>
      <pubDate>Mon, 06 May 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/exploring_graal_next_generation_jit_compilation_for_java/</guid>
      <description>The Graal compiler is a radical leap forward in dynamic, Just-In-Time (JIT) compilation technology. Heralded as a significant factor behind Java&amp;rsquo;s impressive performance, the role and function of JIT compilation within the Java Virtual Machine (JVM) architecture often perplexes many practitioners due to its complex and rather opaque nature.&#xA;What is a JIT compiler? When you execute the javac command or use the IDE, your Java program is converted from Java source code into JVM bytecode.</description>
    </item>
    <item>
      <title>Turbocharge Java Microservices with Quarkus and GraalVM Native Image</title>
      <link>https://iqnev.github.io/posts/graalvm-native-image/</link>
      <pubDate>Sun, 07 Jan 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/graalvm-native-image/</guid>
      <description>In the dynamic landscape of modern software development, microservices have become the favored architectural approach. While this methodology offers numerous advantages, it is not without its challenges. Issues such as large memory footprints, extended start times, and high CPU usage often accompany traditional JVM-based services. These challenges not only impact the technical aspects but also have financial implications that can significantly affect the overall cost of running and maintaining software solutions.</description>
    </item>
    <item>
      <title>Registering Reflection in Quarkus Extensions</title>
      <link>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</link>
      <pubDate>Sun, 26 Nov 2023 14:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</guid>
      <description>Quarkus utilizes ahead-of-time (AOT) compilation to build blazing fast native executables. However, AOT works through closed-world analysis which eliminates unused code paths. This can break functionality relying on runtime reflection like dependency injection, bytecode manipulation, and integration with certain libraries.&#xA;Registering for Reflection When building a native executable, GraalVM operates under a closed-world assumption, analyzing the call tree and eliminating unused classes, methods, and fields. To include elements requiring reflective access, explicit registration becomes crucial.</description>
    </item>
  </channel>
</rss>
