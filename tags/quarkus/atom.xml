<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quarkus on Codes are a puzzle</title>
    <link>https://iqnev.github.io/tags/quarkus/</link>
    <description>Recent content in Quarkus on Codes are a puzzle</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Jun 2024 11:04:18 +0300</lastBuildDate>
    <atom:link href="https://iqnev.github.io/tags/quarkus/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Harnessing Automatic Setup and Integration with Quarkus Dev Services for Efficient Development</title>
      <link>https://iqnev.github.io/posts/harnessing_automatic_setup_and_integration_with_quarkus_dev_services_for_efficient_development/</link>
      <pubDate>Sun, 02 Jun 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/harnessing_automatic_setup_and_integration_with_quarkus_dev_services_for_efficient_development/</guid>
      <description>JPrime 2024 concluded successfully!!&#xA;The organizers of JPrime 2024 have once again gone to great lengths to offer a diverse range of topics, ensuring there&amp;rsquo;s something for everyone.&#xA;However, today&amp;rsquo;s article isn&amp;rsquo;t triggered by one of Michael Simons&amp;rsquo; lectures on &amp;ldquo;The Evolution of Integration Testing within Spring and Quarkus&amp;rdquo; although it was highly insightful. He explored integration testing strategies, focusing on the setup in Spring Boot— a topic I personally steer clear of, but that’s for another day.</description>
    </item>
    <item>
      <title>Turbocharge Java Microservices with Quarkus and GraalVM Native Image</title>
      <link>https://iqnev.github.io/posts/graalvm-native-image/</link>
      <pubDate>Sun, 07 Jan 2024 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/graalvm-native-image/</guid>
      <description>In the dynamic landscape of modern software development, microservices have become the favored architectural approach. While this methodology offers numerous advantages, it is not without its challenges. Issues such as large memory footprints, extended start times, and high CPU usage often accompany traditional JVM-based services. These challenges not only impact the technical aspects but also have financial implications that can significantly affect the overall cost of running and maintaining software solutions.</description>
    </item>
    <item>
      <title>Registering Reflection in Quarkus Extensions</title>
      <link>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</link>
      <pubDate>Sun, 26 Nov 2023 14:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/registering-reflection-in-quarkus-extensions/</guid>
      <description>Quarkus utilizes ahead-of-time (AOT) compilation to build blazing fast native executables. However, AOT works through closed-world analysis which eliminates unused code paths. This can break functionality relying on runtime reflection like dependency injection, bytecode manipulation, and integration with certain libraries.&#xA;Registering for Reflection When building a native executable, GraalVM operates under a closed-world assumption, analyzing the call tree and eliminating unused classes, methods, and fields. To include elements requiring reflective access, explicit registration becomes crucial.</description>
    </item>
    <item>
      <title>Exploring Synthetic Beans in Quarkus: A Powerful Extension Mechanism</title>
      <link>https://iqnev.github.io/posts/exploring-synthetic-beans-in-quarkus-a-powerful-extension-mechanism/</link>
      <pubDate>Sat, 11 Nov 2023 11:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/exploring-synthetic-beans-in-quarkus-a-powerful-extension-mechanism/</guid>
      <description>In the world of Quarkus, the realm of dependency injection is rich and versatile, offering developers a multitude of tools to manage and control beans. One such tool is the concept of synthetic beans. Synthetic beans are a powerful extension mechanism that allows you to register beans whose attributes are not derived from a Java class, method, or field. Instead, all the attributes of a synthetic bean are defined by an extension.</description>
    </item>
    <item>
      <title>Creating Custom Configuration in Quarkus Loaded from JSON File</title>
      <link>https://iqnev.github.io/posts/load-configuration-from-json-file/</link>
      <pubDate>Sat, 14 Oct 2023 21:00:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/load-configuration-from-json-file/</guid>
      <description>Introduction Quarkus, a framework for building lightweight, fast, and efficient Java applications, offers developers the flexibility to create custom configurations loaded from JSON files. These custom configurations can be seamlessly integrated into your Quarkus application, enhancing its configurability and adaptability. To achieve this, Quarkus utilizes Eclipse MicroProfile Config ( MP-Config), with the SmallRye implementation providing the necessary tools. In this article, we&amp;rsquo;ll delve into the process of crafting custom configurations and loading them from JSON files within Quarkus, all while exploring the mechanics of SmallRye&amp;rsquo;s MP-Config implementation.</description>
    </item>
    <item>
      <title>Extending Quarkus: When and How to Write Your Own Extensions</title>
      <link>https://iqnev.github.io/posts/when-and-how-to-write-your-own-extensions/</link>
      <pubDate>Sun, 08 Oct 2023 21:29:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/when-and-how-to-write-your-own-extensions/</guid>
      <description>Quarkus, with its innovative extension framework, offers developers a powerful way to integrate various technologies seamlessly into their applications. These extensions simplify configuration, enable dependency injection, and optimize performance, making it an attractive option for Java developers. However, before diving into creating your own Quarkus extension, it&amp;rsquo;s crucial to understand when it&#39; s necessary and how to do it effectively.&#xA;When to Create a Quarkus Extension Complex Integrations: If you&amp;rsquo;re working with complex frameworks like ORM mappers, reactive clients, or data access libraries, creating an extension can help manage the intricacies of configuration and dependency management.</description>
    </item>
    <item>
      <title>Demystifying Quarkus Extension Development: Jandex vs. AdditionalBeanBuildItem</title>
      <link>https://iqnev.github.io/posts/jandex-vs-additional-bean-builditem/</link>
      <pubDate>Tue, 26 Sep 2023 23:04:18 +0300</pubDate>
      <guid>https://iqnev.github.io/posts/jandex-vs-additional-bean-builditem/</guid>
      <description>Welcome to a comprehensive exploration of two key aspects in Quarkus extension development: Jandex and AdditionalBeanBuildItem. This article aims to elucidate the differences between these approaches, offering insights into their roles, applications, and the intricate interplay between them. By the end, you&amp;rsquo;ll have a clear understanding of how to wield these tools effectively in your Quarkus extensions.&#xA;1. Jandex: Automatic Bean Discovery and Indexing Understanding Jandex and Its Role: In the realm of Quarkus extensions, beans are the building blocks of functionality, and Contexts and Dependency Injection (CDI) is the mechanism that governs their management.</description>
    </item>
  </channel>
</rss>
